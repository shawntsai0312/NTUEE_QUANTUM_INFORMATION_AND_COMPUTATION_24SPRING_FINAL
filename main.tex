%% Please do not delete the following line
%% This is the Overleaf LaTeX template for the journal Nuclear Physics A.
%% Copyright 2007-2020 Elsevier Ltd
%% 
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt`''.
%% 
%% Template article for Elsevier's document class `elsarticle'
%% with harvard style bibliographic references
\documentclass[final,5p,times,twocolumn,authoryear]{elsarticle}
\journal{}  % Leave empty, then the journal name will be printed

% Bold text
\usepackage{bbold}

% Title and section formatting
\usepackage{titlesec}

% Mathematical symbols and fonts
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bm}

% Quantum computing packages
\usepackage{qcircuit}
\usepackage{tikz}
\usepackage{braket}
\usepackage{physics}

% Additional useful packages
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{geometry}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

% Remove "Preprint submitted to Elsevier" line
\makeatletter
\def\ps@pprintTitle{%
 \let\@oddhead\@empty
 \let\@evenhead\@empty
 \def\@oddfoot{\footnotesize\itshape
       \hfill\today}%
 \let\@evenfoot\@oddfoot}
\makeatother

% Change the font of subsection to bold and upright
\titleformat{\section}
  {\normalfont\fontsize{12}{15}\bfseries}{\thesubsection}{1em}{}

% Change the font of subsection to bold and upright
\titleformat{\subsection}
  {\normalfont\fontsize{10}{15}\bfseries}{\thesubsection}{1em}{}

% Change the font of subsubsection to italic
\titleformat{\subsubsection}
  {\normalfont\fontsize{9}{15}\itshape \bfseries}{\thesubsubsection}{1em}{}

\begin{document}

\begin{frontmatter}

    \title{Surface code related paper survey}

    \author{Group 28}

    \begin{abstract}
        %% Text of abstract
        Today, Quantum computers have high error rates compared to the classical computer. In order to make quantum computers useful, error rates have to be as low as 1 in a trillion. While a typical transistor in a microprocessor can run for about a billion years at a billion operations per second, without ever suffering a hardware fault due to any form of interference. A huge improvement in performance is needed, since the typical quantum bits become randomized in about one one-thousandth of a second. Classical error correction employ redundacy, however, it is impossible for quantum code due to no-cloning theorem. In this review, we will summarize one of the promising method – surface code. Besides, the novel improvement of the algorithm and decoder will also be provided.
    \end{abstract}

    %%Graphical abstract
    %\begin{graphicalabstract}
    %\includegraphics{grabs}
    %\end{graphicalabstract}

    %%Research highlights
    %\begin{highlights}
    %\item Research highlight 1
    %\item Research highlight 2
    %\end{highlights}

    \begin{keyword}
        %% keywords here, in the form: keyword \sep keyword, up to a maximum of 6 keywords
        Quantum Computation \sep Quantum Error Correction \sep Surface Code \sep Stabilizer codes

        %% PACS codes here, in the form: \PACS code \sep code

        %% MSC codes here, in the form: \MSC code \sep code
        %% or \MSC[2008] code \sep code (2000 is the default)

    \end{keyword}


\end{frontmatter}

%\tableofcontents

%% \linenumbers

%% main text

\section{Introduction}
\label{introduction}

\subsection{From classical to quantum error correction}

\subsubsection{Classical error correction}

The basic principle behind classical error correction is to increase the bits used to encode information. The exact method to introduce redundancy and retrieve information is known as a correction code. A simple example is the three-bit repetition code: the bit 0 is encoded into three bits as 000, and the bit 1 is encoded into 111, the encoded bit strings are referred to as codewords.

If the message is subject to a single-bit error, we can still retrieve the correct information via a majority vote. However, it is easy to see that this code is vulnerable to two or more bit-flip errors.

The distance $d$ of a code is the minimum number of errors to transform a codeword into another, and its relationship to the number of errors the code can correct $t$ is given by $d=2t+1$. Error correction codes are described in terms of the $[n,k,d]$ notation, where $n$ is the total number of bits per codeword, $k$ is the number of encoded bits and $d$ is the code distance.

\subsubsection{Classical bits to qubits}

Qubits have some distinct characteristics different from classical bits. Its values can be visualized as a point on a sphere, namely the Bloch sphere, and can take on infinite numbers of values.

It may seem like qubits are subject to infinite numbers of errors, however, we can decompose any error by expanding it in terms of the Pauli basis.

\[
    \mathbb{1} =
    \begin{pmatrix}
        1 & 0 \\
        0 & 1
    \end{pmatrix}
    \text{, }
    \quad
    X =
    \begin{pmatrix}
        0 & 1 \\
        1 & 0
    \end{pmatrix}
    \text{, }
    \quad
    Y =
    \begin{pmatrix}
        0 & -i \\
        i & 0
    \end{pmatrix}
    \text{, }
    \quad
    Z =
    \begin{pmatrix}
        1 & 0  \\
        0 & -1
    \end{pmatrix}
\]

\[
    U(\delta \theta, \delta \phi) \ket{\psi} = \alpha_{I} \mathbb{1} \ket{\psi} + \alpha_{X} X \ket{\psi} + \alpha_{Y} Y \ket{\psi} + \alpha_{Z} Z \ket{\psi}
\]

The error correction process involves performing projective measurements that cause the above superposition to collapse to a subset of its terms, and by checking abnormality in parties, we can find a suitable correction process to restore the original quantum information.

\subsubsection{Challenges in quantum error correction}

Qubits states are confined to the no-cloning theorem, thus making it impossible for us to add redundancy by simply copying states and using the tensor product. The second complication in quantum coding arises from the fact that qubits are susceptible to both bit-flips ($X$-errors) and phase-flips ($Z$-errors),  and we need to design codes to detect both errors simultaneously. The last challenge in quantum error correction is the fact that quantum states collapse after measurement, thus the error correction procedure must be carefully chosen so as not to cause the wave function to collapse and erase the encoded information.

\subsection{Quantum redundancy and stabilizer measurements}

In quantum codes, redundancy is added by expanding the Hilbert space in which the qubits are encoded. Taking the two-qubit code as an example, the encoding process is shown below, noting that this process does not disobey the no-cloning theorem:

\[
    \ket{\psi} = \alpha \ket{0} + \beta \ket{1}
    \quad
    \xrightarrow{\text{two-qubit encoder}}
    \quad
    \ket{\psi}_L
\]
\[
    = \alpha \ket{00} + \beta \ket{11} = \alpha \ket{0}_L + \beta \ket{1}_L,
\]

After encoding, the logical qubit occupies a four-dimensional Hilbert space

\[
    \ket{\psi}_L \in \mathcal{H}_4 = \text{span}\{\ket{00}, \ket{01}, \ket{10}, \ket{11}\}
\]

More specifically, the logical qubits are defined within a two-dimensional subspace called the codespace, and bit-flip errors rotate the state into another subspace called the error subspace.

\[
    \ket{\psi}_L \in \mathcal{C} = \text{span}\{\ket{00}, \ket{11}\} \subset \mathcal{H}_4
\]

\[
    X_1 \ket{\psi}_L \in \mathcal{F} \subset \mathcal{H}_4
\]

To differentiate between the codespace and the error space, a projective measurement of $Z_1Z_2$ is performed. The $Z_1Z_2$ operator yields a (+1) eigenvalue when applied to the logical state, and is said to stabilize the logical qubit. On the other hand, The $Z_1Z_2$ operator yields a (-1) eigenvalue when applied to errored states. Note that the coefficients stay undisturbed during this parity check.

\[
    Z_1Z_2\ket{\psi}_L = Z_1Z_2(\alpha \ket{00} + \beta \ket{11}) = (+1) \ket{\psi}_L
\]

The figure shows the circuit implementation of the two-qubit code. Following the error stage, an ancilla qubit $\ket{0}_A$ is introduced to measure the $Z_1Z_2$ stabilizer. The ancilla's outcome is referred to as a syndrome, and we can construct a syndrome table that shows the outcome of the syndrome corresponding to possible errors.
\\
\\
\textbf{Circuit and table here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
In this correction scheme, we can conclude that the logical qubit is subject to a bit-flip error if we measure the ancilla and get the syndrome 1. It requires simultaneous bit-flip errors on both qubits such that we do not notice any error, thus suppressing the error rate. Note that we could not determine which qubit had been subject to the bit-flip mistake even if we acknowledge the existence of it, thus more sophisticated codes must be designed to fulfill the purpose of error detection and correction.

\subsection{Stabilizer codes and operators}

This section briefly discusses the operation of the general $[[n, k, d]]$ stabilizer code, discussing basic concepts sufficient for readers to understand key concepts of recent papers we have surveyed.

The circuit below shows the basic structure of an $[[n,k,d]]$ stabilizer code. A register of $k$ data qubits is entangled with $m = n - k$ redundancy qubits to create a logical qubit, errors can then be detected by performing $m$ stabilizer measurements $\Pi$. 

Constructing a good code involves finding stabilizers that anti-commute with the errors to be detected so that the presence of errors will be detected via syndrome.

The result of the m stabilizer measurements gives us an $m$-bit syndrome, we then deduce the best recovery operation to restore the logical state to the codespace using various decoding algorithms, since for large numbers of qubits it is impossible to enumerate errors for all possible syndromes.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
\subsubsection{Properties of the stabilizers}

The stabilizers $\Pi$ must satisfy some properties. Firstly, they must stabilize all logical states, which means when the stabilizers act on any logical state, they must return the eigenvalue 1. Secondly, all the stabilizers of a code must commute with one another, this is necessary so that the stabilizers can be measured simultaneously.

\subsubsection{Logical operators}

An $[[n,k,d]]$ stabilizer code has $2k$ logical Pauli operators that allow for logical states to be modified without having to decode and then re-encode. Each logical operator must commute with all the code stabilizers.

Finding sets of stabilizers and logical operators is not trivial, and needs to be found with effort.

\subsubsection{Quantum error correction with stabilizer codes}

The figure below shows the general error correction procedure for a single cycle of an $[[n,k,d \geq 3]]$ stabilizer code.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
After the logical qubit is subject to an error, stabilizer measurements are performed to produce an $m$-bit syndrome $\mathcal{S}$. The next step, referred to as decoding, involves processing the syndrome to determine the best unitary operation $\mathcal{R}$ to return the logical state to the codespace. The decoding step is successful if the combined action of $\mathcal{R}E$ on the code state is as follows
\[
    \mathcal{R}E \ket{\psi}_L = (+1) \ket{\psi}_L
\]
The decoding step fails if the recovery operation maps the code state as follows
\[
    \mathcal{R}E \ket{\psi}_L = L \ket{\psi}_L
\]
The recovery process rotates the qubit into the codespace but leads to a change in the encoded information.

\subsection{Surface code}

Commuting sets of stabilizers enable the ability to detect different errors simultaneously without disturbing information. Finding such sets is non-trivial, and special codes have to be designed.

The general design principle behind the surface code is that the code is built up by patching repeated elements. This approach ensures that the surface code can be straightforwardly scaled whilst ensuring stabilizer commutativity. One advantage of the surface code is that it requires only nearest-neighbor interactions, as high-fidelity long-range interactions are difficult to maintain.

\subsubsection{The surface code four-cycle}

The basic element in the surface code is shown in the figure below, squares represent ancilla qubits, while circles represent data qubits. Black edges represent controlled $X$ gates, each controlled on an ancilla qubit $A$ and acting on a data qubit $D$. Likewise, the dashed edges represent controlled-$Z$ operations, each controlled by an ancilla qubit and acting on a data qubit.
For example, ancilla $A_1$ measures the stabilizer $XD_1XD_2$.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
The surface code four-cycle is not useful itself as it encodes $k=n-m=0$ qubits, but working detection and correction codes can be formed by tiling together multiple four-cycles to form square lattices.

\subsubsection{The $[[5, 1, 2]]$ surface code}

The figure below shows the five-qubit surface code formed by tiling four four-cycles in a square.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
The stabilizers can be read off to give

The logical operators of the surface code can be defined as chains of Pauli operators along the edges of the boundaries of the surface code. For example, $XD_1XD_4$ and $ZD_1ZD_2$ are both valid operators.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\
From the above we see that the minimum weight of the logical operators is 2, meaning the $[[5,1,2]]$ code is a detection code with $d=2$.

\subsubsection{Scaling}

The distance of a surface code can be increased simply by scaling the size of the lattice. The figure shown below is the $[[13, 1, 3]]$ surface code, stabilizers and operators can be read off just by inspection.
\\
\\
\textbf{Circuit here}
\\
\textbf{Use the qcircuit package to draw the circuit}
\\
\\

\subsection{Practical considerations}
\subsubsection{Decoding algorithms}
Given a code syndrome, the role of the decoder is to find the best recovery operation to restore the quantum information into the codespace. For small code examples, it is possible to compute the lookup table for all combination of errors. However, as the code size increases, the number of possible syndromes grows exponentially, and it becomes impractical to use such decoding strategy.

In place of lookup tables, decoding algorithms are developed to decode syndromes. For surface codes, one technique known as minimum weight perfect matching (MWPM) can be used for decoding, which works by identifying error chains between positive syndrome measurements.

For these approximate inference techniques, the logical error rate of a quantum error correction code will depend heavily on the decoder used, and the efficiency of the decoder is also a topic that researchers opt to optimize.

\subsubsection{Experimental implementation}
The experimental implementation of the surface code represents a significant milestone in quantum computing, aiming to achieve fault-tolerant logical qubits. Researchers at institutions like Google, IBM, and TU Delft are at the forefront, developing superconducting devices to realize this goal. The surface code known for its high threshold for error rates under realistic noise conditions, demands sophisticated hardware capable of maintaining low error rates.

\subsubsection{Fault tolerant}
In the part where we introduce basic working principles of the surface code, we have assumed that errors happen in certain parts of the circuit. In realistic environments, however, this is not the case as errors could also appear at two-qubit gates or stabiliser measurements

A fault-tolerant code is a code that could handle errors up to the code distance occurring at any location in the circuit. This involves modifying quantum circuits, which increases overhead by requiring additional ancilla qubits.

%% If you have bibdatabase file and want bibtex to generate the
%% bibitems, please use
%%
\bibliographystyle{elsarticle-harv}
\bibliography{example}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

%%\begin{thebibliography}{00}

%% \bibitem[Author(year)]{label}
%% For example:

%% \bibitem[Aladro et al.(2015)]{Aladro15} Aladro, R., Martín, S., Riquelme, D., et al. 2015, \aas, 579, A101


%%\end{thebibliography}

\end{document}

\endinput
%%
%% End of file `elsarticle-template-harv.tex'.
